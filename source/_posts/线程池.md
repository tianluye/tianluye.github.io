---
title: 线程池
date: 2022-03-02 22:36:19
tags: [多线程, 并发]
categories: 并发
top: 2
---

### 何为线程池？

线程池，是一种线程的使用模式，它为了 **<font color=RED face="宋体">降低线程使用中频繁的创建和销毁所带来的资源消耗与代价</font>**。
通过创建一定数量的线程，让他们时刻准备就绪等待新任务的到达，而任务执行结束之后再重新回来继续待命。

这就是线程池最核心的设计思路，「**复用线程，平摊线程的创建与销毁的开销代价**」。

### 为何需要线程池？

线程的创建和销毁，都涉及到系统调用，比较消耗系统资源，所以就引入了线程池技术，避免频繁的线程创建和销毁。

相比于来一个任务创建一个线程的方式，使用线程池的优势体现在如下几点：

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗
2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

线程池的实现天生就实现了异步任务接口，允许你提交多个任务到线程池，线程池负责选用线程执行任务调度。

 ### 创建线程池

Executors提供五种线程池：

1. newCachedThreadPool ：缓存线程池，如果线程池长度超过处理需要，可回收空闲线程，若无可回收，则新建线程。
2. newFixedThreadPool ： 定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
3. newScheduledThreadPool ： 计划线程池，支持定时及周期性任务执行。
4. newSingleThreadExecutor ： 单线程线程池，用唯一的线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
5. newWorkStealingPool ： 支持 fork/join框架的线程池，1.8才支持

注意：在创建线程池的时候不推荐使用 Executors工具类，最好就使用 ThreadPoolExecutor类来创建。使用 Executors工具类，有概率会造成 OOM内存溢出的问题。比如 newFixedThreadPool内部使用的是无边界的 LinkedBlockingQueue队列，其内部方法 offer实现，在队列尾部添加一个元素，默认无参构造出来的最大边界值为 Integer.MAX_VALUE，所以会造成内存溢出。

```
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

public LinkedBlockingQueue() {
    this(Integer.MAX_VALUE);
}

// 因为是无参构造器，capacity = Integer.MAX_VALUE
public boolean offer(E e, long timeout, TimeUnit unit)
    throws InterruptedException {
    if (e == null) throw new NullPointerException();
    long nanos = unit.toNanos(timeout);
    int c = -1;
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        while (count.get() == capacity) {
            if (nanos <= 0)
                return false;
            nanos = notFull.awaitNanos(nanos);
        }
        // last = last.next = node; 列尾添加一个元素
        enqueue(new Node<E>(e));
        c = count.getAndIncrement();
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
    return true;
}
```

正确创建线程池的方式：

```
private ThreadFactory namedThreadFactory = newThreadFactoryBuilder().setNameFormat("thread-call-runner-%d").build();
/**
 * 创建核心线程 5，最大线程池容量 10的线程池，主要设置阻塞队列的 capacity   
 */
private ExecutorService executorService = new ThreadPoolExecutor(5,10,200L,
        TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(10), namedThreadFactory
);
```

#### 线程池的创建

通过 `ThreadPoolExecutor`来创建一个线程池

```
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
}
```

创建一个线程池需要输入几个参数：

- `corePoolSize`（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的`prestartAllCoreThreads`方法，线程池会提前创建并启动所有基本线程。
- `maximumPoolSize`（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。
- `keepAliveTime` ： 如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。是否允许超时退出则取决于下面的逻辑。
- `unit` : keepAliveTime的时间单元
- `workQueue` : 用于保存等待执行的任务的阻塞队列。
- `threadFactory` : 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。
- `handler` : 饱和策略

##### 是否允许核心线程超时退出

由 `allowCoreThreadTimeOut`字段来控制：

- 如果该值为 false，且 `poolSize <= corePoolSize`，线程池都会保证这些核心线程处于存活状态，不会超时退出。
- 如果为 true，则不论 poolSize的大小，都允许超时退出。
- 如果 `poolSize > corePoolSize`，则该参数不论 true还是 false，都允许超时退出。

##### 阻塞队列 BlockingQueue<Runnable> workQueue

- `ArrayBlockingQueue`：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
- `LinkedBlockingQueue`：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
- `SynchronousQueue`：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
- `PriorityBlockingQueue`：一个具有优先级得无限阻塞队列。
- `DelayQueue`：一个使用优先级队列实现的无界阻塞队列。
- `LinkedTransferQueue`：一个由链表结构组成的无界阻塞队列。
- `LinkedBlockingDeque`：一个由链表结构组成的双向阻塞队列。

##### 饱和策略 RejectedExecutionHandler handler

当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略 :

- CallerRunsPolicy：只用调用者所在线程来运行任务。
- DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
- DiscardPolicy：不处理，丢弃掉。
- 当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。

##### poolSize、corePoolSize、maximumPoolSize三者的关系

```
corePoolSize：线程池的基本大小。
maximumPoolSize：线程池中允许的最大线程数。
poolSize：线程池中当前线程的数量。
```

当新提交一个任务时：

- 如果 `poolSize < corePoolSize`，新增加一个线程处理新的任务。
- 如果 `poolSize = corePoolSize`，新任务会被放入阻塞队列等待。
- 如果阻塞队列的容量达到上限，且这时 `poolSize < maximumPoolSize`，新增线程来处理任务。
- 如果阻塞队列满了，且 `poolSize = maximumPoolSize`，那么线程池已经达到极限，会根据饱和策略 `RejectedExecutionHandler`拒绝新的任务。

![image](file:///D://image/00042.png?ynotemdtimestamp=1646231725217)

#### 线程池的关闭

我们可以通过调用线程池的 `shutdown`或 `shutdownNow`方法来关闭线程池，但是它们的实现原理不同。

- `shutdown` : 只是将线程池的状态设置成 SHUTDOWN状态，然后中断所有没有正在执行任务的线程。
- `shutdownNow` : 遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。

只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。

#### 合理的配置线程池

##### 任务的性质：CPU密集型任务，IO密集型任务和混合型任务

任务性质不同的任务可以用不同规模的线程池分开处理。`CPU密集型任务配置尽可能少的线程数量`，如配置 `Ncpu + 1`个线程的线程池。`IO密集型任务`则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如 `2 * Ncpu`。`混合型的任务`，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 `Runtime.getRuntime().availableProcessors()`方法获得当前设备的CPU个数。

##### 任务的优先级：高，中和低

优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。

##### 任务的执行时间：长，中和短

执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。

##### 任务的依赖性：是否依赖其他系统资源，如数据库连接

依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。

建议使用 `有界队列`，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。

#### 线程池的监控

通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用 :

- `taskCount`：线程池需要执行的任务数量。
- `completedTaskCount`：线程池在运行过程中已完成的任务数量。小于或等于taskCount。
- `largestPoolSize`：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。
- `getPoolSize`:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。
- `getActiveCount`：获取活动的线程数。

通过扩展线程池进行监控。通过继承线程池并重写线程池的`beforeExecute，afterExecute和terminated`方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。

```
protected void beforeExecute(Thread t, Runnable r) { }
protected void afterExecute(Runnable r, Throwable t) { }
protected void terminated() { }

class PausableThreadPoolExecutor extends ThreadPoolExecutor {
    private boolean isPaused;
    private ReentrantLock pauseLock = new ReentrantLock();
    private Condition unpaused = pauseLock.newCondition();
    public PausableThreadPoolExecutor(...) { super(...); }
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        pauseLock.lock();
        try {
            while (isPaused) unpaused.await();
        } catch (InterruptedException ie) {
            t.interrupt();
        } finally {
            pauseLock.unlock();
        }
    }
    public void pause() {
        pauseLock.lock();
        try {
            isPaused = true;
        } finally {
            pauseLock.unlock();
        }
    }
    public void resume() {
        pauseLock.lock();
        try {
            isPaused = false;
            unpaused.signalAll();
        } finally {
            pauseLock.unlock();
        }
    }
}
```





































































**一、线程池创建**

先看一下ThreadPoolExecutor参数最全的构造方法：

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231216070-693632307.png)

![img](https://note.youdao.com/src/E8ABF32F4F2E4CD7B0D1AACA16127568)

①corePoolSize：线程池的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。

②maximumPoolSize:最大线程数，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。

③keepAliveTime:线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。

⑤unit：这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。

⑥workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。

⑦threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。

⑧handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。

以上就是创建线程池时用到的参数，面试中经常会有面试官问道这个问题。

 

**二、线程池执行流程**

这里用一个图来说明线程池的执行流程

![img](https://note.youdao.com/src/502A3968315E4681B53AD46B25E93560)

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231231929-1280812291.png)

任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。

 

这里以jdk1.8.0_111的源代码为例，看一下具体实现。

**1、先看一下线程池的executor方法**

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231325648-245385391.png)

![img](https://note.youdao.com/src/960391D21F0040A8A8398DC4CC63857B)

①：判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务

②：如果不小于corePoolSize，则将任务添加到workQueue队列。

③：如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。

 

**2、再看下addWorker的方法实现**

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231554601-390531474.png)

![img](https://note.youdao.com/src/DC5277F6281B47A4A5B7A7819FE33992)

这块代码是在创建非核心线程时，即core等于false。判断当前线程数是否大于等于maximumPoolSize，如果大于等于则返回false，即上边说到的③中创建线程失败的情况。

 

addWorker方法的下半部分：

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231659117-129178066.png)

![img](https://note.youdao.com/src/A0FADFA4C77F430098AF77FC156BCE13)

①创建Worker对象，同时也会实例化一个Thread对象。

②启动启动这个线程

 

**3、再到Worker里看看其实现**

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231743648-994771431.png)

![img](https://note.youdao.com/src/EFAD863C971944EBB6112A56057537F2)

可以看到在创建Worker时会调用threadFactory来创建一个线程。上边的②中启动一个线程就会触发Worker的run方法被线程调用。

 

**4、接下来咱们看看runWorker方法的逻辑**

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231758929-977183448.png)

![img](https://note.youdao.com/src/EB2BF6D2A55A48DB8D40C35B67A1C1D0)

线程调用runWoker，会while循环调用getTask方法从workerQueue里读取任务，然后执行任务。只要getTask方法不返回null,此线程就不会退出。

 

**5、最后在看看getTask方法实现**

![img](https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231901007-1866682344.png)

![img](https://note.youdao.com/src/0C425896BA9344CA894FFE51674D5364)

①咱们先不管allowCoreThreadTimeOut，这个变量默认值是false。wc>corePoolSize则是判断当前线程数是否大于corePoolSize。

②如果当前线程数大于corePoolSize，则会调用workQueue的poll方法获取任务，超时时间是keepAliveTime。如果超过keepAliveTime时长，poll返回了null，上边提到的while循序就会退出，线程也就执行完了。

如果当前线程数小于corePoolSize，则会调用workQueue的take方法阻塞在当前。

 

 

\---------------------------------------------------------------